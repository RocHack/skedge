(function() {
  var Tooltip = ReactBootstrap.Tooltip;
  var OverlayTrigger = ReactBootstrap.OverlayTrigger;
  
  window.Results = React.createClass({
    mixins: [Reflux.connect(SKScheduleStore, "store"),
             Reflux.connect(SKSocialStore, "social")],

    getInitialState: function() {
      return {
        readds: {}
      };
    },

    shouldComponentUpdate: function(nextProps, nextState) {
      if (this.state.store.temporaryAdds.length ||
          this.state.store.temporaryDeletes.length ||
          nextState.store.temporaryAdds.length ||
          nextState.store.temporaryDeletes.length) {
        return false;
      }
      return true;
    },

    hover: function(section, inTrue_outFalse) {
      if (!section.startTime || section.status == CANCELLED) {
        return;
      }

      if (inTrue_outFalse) {
        SKScheduleAction.temporaryizeSection(section);
      }
      else {
        SKScheduleAction.untemporaryizeSection(section); 
      }
    },

    changeBookmark: function(course) {
      SKScheduleAction.changeBookmark(course);
    },

    commitSection: function(section, fromReadd) {
      if (!section.startTime) {
        return;
      }

      // calculate readds
      // see if this was contained in any re-adds, if so, remove the readd button
      for (sectionCRN in this.state.readds) {
        var readdsPerSection = this.state.readds[sectionCRN];
        for (var i = readdsPerSection.length - 1; i >= 0; i--) {
          if (readdsPerSection[i].crn == section.crn) {
            readdsPerSection.splice(i, 1);

            this.setState({readds:this.state.readds});
            break;
          }
        }
      }

      var trackingProps = {crn: section.crn};

      // calculate any new readds to place, if it wasn't from a readd
      if (!fromReadd) {
        var conflicts = SKScheduleStore.getConflicts(section);

        trackingProps.name = "commit-section";
        trackingProps.readd = false;
        trackingProps.add = (conflicts != null);
        trackingProps.conflicts = (conflicts != null && conflicts.length > 0);

        if (conflicts && conflicts.length > 0) {
          var readds = this.state.readds;
          if (!readds[section.crn]) {
            readds[section.crn] = [];
          }
          readds[section.crn] = readds[section.crn].concat(conflicts);
          this.setState({readds:readds});
        }
      }
      else {
        trackingProps.readd = true;
        trackingProps.add = true;
      }

      ahoy.track("$click", trackingProps);

      SKScheduleAction.commitSection(section);
    },

    getOpenedSubsections: function(course) {
      if (!this.state.store.schedules[course.yrTerm]) {
        return null;
      }
      var sections = this.state.store.schedules[course.yrTerm].sections;
      var opened = [];
      for (var i = 0; i < sections.length; i++) {
        if (sections[i].sectionType != MAIN && sections[i].course.id == course.id)
        {
          opened.push(sections[i].sectionType);
        }
      }
      return opened;
    },

    render: function() {
      var self = this;
      var results;
      if (this.props.searchError) {
        results = (~
          %p.lead.no-results
            {this.props.searchError}
        ~);
      }
      else if (this.props.courseGroups.length == 0) {
        results = (~
          %p.lead.no-results
            no results found
        ~);
      }
      else {
        results = this.props.courseGroups.map(function(courses) {
          var groupName = courses[0].term + " " + courses[0].year;
          var group = courses.map(function (course) {
            var type = self.getOpenedSubsections(course);
            var bookmarked = self.state.store.bookmarks.some(function(bk) {
              return bk.id == course.id;
            });
            var liked = self.state.social.likes.some(function(like) {
              return like.id == course.id;
            });

            return (~
              %CourseResult(course={course}
                            readds={self.state.readds}
                            openedSubsections={type}
                            key={"course-"+course.id}
                            hover={self.hover}
                            commitSection={self.commitSection}
                            bookmarked={bookmarked}
                            changeBookmark={self.changeBookmark}
                            like={liked}
                            friends={self.state.social.friends}
                            socialLoggedIn={self.state.social.loggedIn})
            ~);
          });
          return (~
            .results-group(key={"group-"+groupName})
              %h2.results-group-header
                {self.props.bookmarks ? "My Bookmarks" : groupName}

              {group}
          ~);
        });
      }

      return (~
        .search-results
          .search-info
          {results}
      ~);
    }
  });
})();
